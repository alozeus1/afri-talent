You are the AfriTalent CTO Team Lead in Claude Code.

Current state (already implemented):
- Next.js App Router UI at frontend/src/app/candidate/ai-assistant/page.tsx
- orchestrator client + types: orchestratorClient.ts + orchestratorTypes.ts
- header nav link gated by CANDIDATE role
- Backend orchestrator exists: /api/orchestrator/run with 6 specialist Claude agents
- Golden test script exists and passes request validation fixes (job_id not required UUID)

MISSION: Spin up agent teams and complete “AI Assistant MVP is shippable” with production-grade hardening, persistence, job ingestion, and ops readiness.

NON-NEGOTIABLES:
- Keep diffs minimal and scoped.
- No breaking changes to existing working UI/endpoint.
- Token discipline: each agent gets max 2 iterations; Team Lead stops loops.
- Team Lead is responsible for final integration, conflict resolution, and final report.

CREATE 5 AGENT TEAMS (run concurrently):
Team A — Backend Persistence & Audit
Team B — Job Ingestion & Job Search MVP
Team C — Frontend UX/Polish & Download/History
Team D — Security/Ratelimit/Abuse Controls
Team E — Observability + CI + Deployment Readiness

For each team:
- Assign a lead agent and 1–2 helper agents.
- Provide them a checklist with “done” acceptance criteria.
- Each team outputs: file list changed + how to test.

Final deliverable:
- A single merged code state where:
  (1) Apply Pack runs persist in Postgres with run history
  (2) Candidate can view last 10 runs and re-download artifacts
  (3) Jobs can be added via manual entry AND at least one ingestion method (RSS/feed/Greenhouse/Lever/etc.)
  (4) Rate limiting + request size guardrails + auth checks are enforced
  (5) Logging includes run_id and agent token usage with errors
  (6) CI has a basic test that calls orchestrator in a mocked mode OR validates schemas and route wiring
- Provide a concise final report + commands to run tests locally.

Start now: create the teams and begin work concurrently.
Do not ask me questions; infer the stack from repo (Node backend, Next.js frontend, Postgres).

TEAM A: Backend Persistence & Audit (Postgres)

Objective:
Persist orchestrator runs and enable DB-backed caching & history.

Scope:
- Add tables + persistence layer:
  ai_runs, resume_versions, job_versions, match_scores, tailored_resume_versions, cover_letter_versions, guard_reports
- Hash resume_text and job.raw_text (sha256) to reuse versions
- Store minimal PII: prefer storing structured JSON and hashes; raw text optional behind a flag
- On each /api/orchestrator/run:
  - create run_id (already exists)
  - persist per-agent call usage (model, tokens, status)
  - persist outputs (resume_json, parsed job_json, match, tailored, cover, guard)
  - implement “get run history” endpoint for candidate: GET /api/orchestrator/runs?limit=10

Acceptance:
- Running apply_pack results in DB rows created and retrievable
- Golden test still passes
- A new endpoint returns last 10 runs for authenticated candidate

Constraints:
- Minimal diffs. Follow existing DB/migration conventions in repo (inspect current setup; don’t invent a new ORM).
- Avoid changing core orchestrator logic unless necessary.

Deliverable:
- Migration files + persistence code + route for history + brief test steps.

TEAM B: Job Ingestion & Job Search MVP

Objective:
Provide a real “Find Jobs” layer so matching uses actual job objects, not only manual text.

Scope (MVP, minimal):
1) Add a backend jobs table + endpoint:
   - POST /api/jobs (create job; can store raw_text, title, company, location, url, source)
   - GET /api/jobs?query=&limit= (simple search)
2) Add at least ONE ingestion method:
   - Option 1: ingest from a public RSS/Atom feed
   - Option 2: ingest from a Greenhouse/Lever JSON job feed
   - Option 3: ingest from a simple “import jobs from URL list” file
Choose the easiest supported by the repo.
3) Ensure jobs created can be passed into orchestrator from UI:
   - job_id should be DB UUID
   - raw_text stored; if missing, orchestrator can still accept raw_text

Acceptance:
- Jobs can be created manually via API
- At least one ingestion method populates jobs table
- Candidate UI can select existing jobs (optional in this sprint) OR backend is ready for it

Deliverable:
- Table migration + endpoints + ingestion script/cron + how to run.

TEAM C: Frontend UX/Polish & Run History

Objective:
Make the AI Assistant a complete product flow: pick jobs, run match/apply pack, view history, download artifacts.

Scope:
1) Add “Run History” panel:
   - fetch GET /api/orchestrator/runs?limit=10
   - show run_id, created_at, selected job title/company if available, top score
   - click to load a past run into the results view and enable downloads
2) Add “Job picker” (if Team B exposes GET /api/jobs):
   - search input -> list jobs -> select job -> fills job text automatically or uses job_id
   - keep manual job paste as fallback
3) UX hardening:
   - clear error rendering for 400/401/429
   - disable buttons correctly
   - show progress status per stage (parse, match, tailor, guard)
4) Ensure consistent styling; keep it simple.

Acceptance:
- Candidate can generate apply pack and later retrieve it from history
- Download buttons work for past runs too
- No TS errors; page loads fast; no infinite re-renders

Deliverable:
- Frontend changes + testing steps.

TEAM D: Security, Rate Limiting, Abuse Controls

Objective:
Prevent runaway costs and abuse in production.

Scope:
1) Add server-side rate limiting for:
   - /api/orchestrator/run (per user, per minute)
   - /api/jobs ingestion (admin only if applicable)
2) Enforce request size limits and sanitize:
   - resume_text max chars
   - job.raw_text max chars
   - max jobs per request
3) Ensure auth enforcement:
   - orchestrator endpoints require authenticated candidate (except dev test mode if present)
4) Add safe logging policy:
   - never log full resume/job text
   - log hashes + run_id + counts
5) Add a “cost cap” guardrail:
   - if token_budget_total exceeds configured max, reject

Acceptance:
- Rate limit returns 429 with friendly message
- Oversized payload returns 400 with clear field error
- No PII in logs

Deliverable:
- Middleware + config + brief docs.

TEAM E: Observability + CI + Deployment Readiness

Objective:
Make it deployable to staging/prod with confidence.

Scope:
1) Add structured logging:
   - include run_id, user_id, stage, model, tokens, duration, status
2) Add health checks:
   - backend /health already exists; add /ready (checks DB connectivity)
3) CI:
   - Add minimal test that validates:
     - orchestrator request schema validator
     - route exists
     - can run in “mock mode” without calling Claude (if repo supports env MOCK_AI=1)
   If mock mode doesn’t exist, add it safely:
     - when MOCK_AI=1, return deterministic stub outputs matching schemas
4) Env docs:
   - Document required env vars for backend and frontend
   - Add staging/prod notes

Acceptance:
- CI passes without Claude credentials (mock mode)
- /ready returns 200 only when DB is reachable
- Clear docs exist

Deliverable:
- Logging + readiness + CI config + docs.

TEAM LEAD GOVERNANCE

- Run teams concurrently but keep them isolated by file ownership:
  Team A: backend/db + backend/src/routes/orchestrator* + persistence modules
  Team B: backend/src/routes/jobs* + ingestion scripts + jobs migrations
  Team C: frontend/src/app/candidate/ai-assistant/* + api client usage
  Team D: backend middleware/config + auth guards
  Team E: backend logging + readiness route + CI + docs

- Token discipline:
  - Each team max 2 iterations.
  - If a team can’t finish within 2 iterations, they must output partial progress + TODO list.

- Merge strategy:
  1) Merge Team A migrations first (DB foundation)
  2) Merge Team B jobs table next
  3) Merge Team C UI integrations (history + job picker)
  4) Merge Team D rate limits/guards
  5) Merge Team E mock mode + CI

- Final check commands:
  Backend: npm test (if exists) + npm run dev
  Frontend: npm run dev + npx tsc --noEmit
  Golden test: RUN_TYPE=apply_pack TOKEN_BUDGET=60000 ./backend/scripts/orchestrator_golden_test.sh