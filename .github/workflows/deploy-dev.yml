name: Deploy Dev

on:
  push:
    branches: [develop]

concurrency:
  group: deploy-dev
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 108188564905.dkr.ecr.us-east-1.amazonaws.com

jobs:
  # ── Step 1: Provision all AWS infrastructure via Terraform ─────────────────
  provision-infra:
    name: Provision Infrastructure (Terraform)
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      ecs_cluster:       ${{ steps.tf-outputs.outputs.ecs_cluster }}
      backend_service:   ${{ steps.tf-outputs.outputs.backend_service }}
      frontend_service:  ${{ steps.tf-outputs.outputs.frontend_service }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Bootstrap Terraform state backend
        env:
          BUCKET: afritalent-dev-terraform-state
          TABLE: afritalent-dev-terraform-locks
        run: |
          # Idempotent — safe to run on every push; no-ops if resources exist
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Creating S3 state bucket: $BUCKET"
            aws s3api create-bucket --bucket "$BUCKET" --region us-east-1
            aws s3api put-bucket-versioning \
              --bucket "$BUCKET" \
              --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption \
              --bucket "$BUCKET" \
              --server-side-encryption-configuration \
                '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block \
              --bucket "$BUCKET" \
              --public-access-block-configuration \
                "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket $BUCKET already exists"
          fi

          if ! aws dynamodb describe-table --table-name "$TABLE" --region us-east-1 2>/dev/null; then
            echo "Creating DynamoDB lock table: $TABLE"
            aws dynamodb create-table \
              --table-name "$TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region us-east-1
            aws dynamodb wait table-exists --table-name "$TABLE" --region us-east-1
          else
            echo "DynamoDB table $TABLE already exists"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: infra/terraform
        run: terraform init -backend-config=envs/dev/backend.config

      - name: Terraform Apply
        working-directory: infra/terraform
        run: terraform apply -auto-approve -var-file=envs/dev/terraform.tfvars

      - name: Capture Terraform outputs
        id: tf-outputs
        working-directory: infra/terraform
        run: |
          echo "ecs_cluster=$(terraform output -raw ecs_cluster_name)"           >> "$GITHUB_OUTPUT"
          echo "backend_service=$(terraform output -raw ecs_backend_service_name)"  >> "$GITHUB_OUTPUT"
          echo "frontend_service=$(terraform output -raw ecs_frontend_service_name)" >> "$GITHUB_OUTPUT"

  # ── Step 2a: Build & push backend image to ECR ─────────────────────────────
  build-push-backend:
    name: Build & Push Backend
    runs-on: ubuntu-latest
    needs: [provision-infra]
    permissions:
      id-token: write
      contents: read
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        id: build
        env:
          ECR_REPOSITORY: afritalent-dev-backend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/$ECR_REPOSITORY
          docker build -t $IMAGE:$IMAGE_TAG -t $IMAGE:latest ./backend
          docker push $IMAGE:$IMAGE_TAG
          docker push $IMAGE:latest
          echo "image=$IMAGE:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

  # ── Step 2b: Build & push frontend image to ECR ────────────────────────────
  build-push-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest
    needs: [provision-infra]
    permissions:
      id-token: write
      contents: read
    outputs:
      image: ${{ steps.build.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push frontend image
        id: build
        env:
          ECR_REPOSITORY: afritalent-dev-frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE=${{ env.ECR_REGISTRY }}/$ECR_REPOSITORY
          docker build \
            --build-arg NEXT_PUBLIC_API_URL=https://api.dev.afri-talent.com \
            --build-arg NEXT_PUBLIC_BACKEND_URL=https://api.dev.afri-talent.com \
            -t $IMAGE:$IMAGE_TAG -t $IMAGE:latest ./frontend
          docker push $IMAGE:$IMAGE_TAG
          docker push $IMAGE:latest
          echo "image=$IMAGE:$IMAGE_TAG" >> "$GITHUB_OUTPUT"

  # ── Step 3: Deploy new images to ECS ───────────────────────────────────────
  deploy-ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [provision-infra, build-push-backend, build-push-frontend]
    permissions:
      id-token: write
      contents: read
    env:
      ECS_CLUSTER:      ${{ needs.provision-infra.outputs.ecs_cluster }}
      BACKEND_SERVICE:  ${{ needs.provision-infra.outputs.backend_service }}
      FRONTEND_SERVICE: ${{ needs.provision-infra.outputs.frontend_service }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Force new backend deployment
        run: |
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$BACKEND_SERVICE" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Force new frontend deployment
        run: |
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$FRONTEND_SERVICE" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for services stable
        run: |
          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER" \
            --services "$BACKEND_SERVICE" "$FRONTEND_SERVICE" \
            --region ${{ env.AWS_REGION }}

      # Rollback: revert the commit and push, or run:
      #   aws ecs update-service --cluster <cluster> --service <svc> \
      #     --task-definition <previous-task-def-arn> --force-new-deployment
